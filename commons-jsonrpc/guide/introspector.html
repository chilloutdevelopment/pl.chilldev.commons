<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.7.1 at 2016-08-27 
 | Rendered using Apache Maven Fluido Skin 1.5
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20160827" />
    <meta http-equiv="Content-Language" content="en" />
    <title>ChillDev Commons JSON-RPC &#x2013; Service introspector</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.5.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />

      
    <script type="text/javascript" src="../js/apache-maven-fluido-1.5.min.js"></script>

                      </head>
        <body class="topBarDisabled">
          
        
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>ChillDev Commons JSON-RPC</h2>
                </div>
                      </div>
        <div class="pull-right">                  <a href="http://wrzasq.pl" id="bannerRight">
                <h2><img src="http://static.wrzasq.pl/images/wrzasqpl.png" alt="Wrzasq.pl"/></h2>
                </a>
      </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
              
            
              
      
                            </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
              
                <ul class="nav nav-list">
                    <li class="nav-header">Main</li>
                              
      <li>
  
                          <a href="https://github.com/chilloutdevelopment/pl.chilldev.commons/" class="externalLink" title="GitHub project">
          <span class="none"></span>
        GitHub project</a>
            </li>
                
      <li>
  
                          <a href="http://chilldev.pl/" class="externalLink" title="Chillout Development">
          <span class="none"></span>
        Chillout Development</a>
            </li>
                
      <li>
  
                          <a href="http://wrzasq.pl/" class="externalLink" title="Wrzasq.pl">
          <span class="none"></span>
        Wrzasq.pl</a>
            </li>
                
      <li>
  
                          <a href="https://www.facebook.com/chilldev" class="externalLink" title="ChillDev @ Facebook">
          <span class="none"></span>
        ChillDev @ Facebook</a>
            </li>
                
      <li>
  
                          <a href="https://www.facebook.com/wrzasqpl" class="externalLink" title="Wrzasq.pl @ Facebook">
          <span class="none"></span>
        Wrzasq.pl @ Facebook</a>
            </li>
                              <li class="nav-header">Parent Project</li>
                              
      <li>
  
                          <a href="../../index.html" title="ChillDev Commons">
          <span class="none"></span>
        ChillDev Commons</a>
            </li>
                              <li class="nav-header">Guide</li>
                              
      <li>
  
                          <a href="../guide/rpc.html" title="JSON-RPC - dispatcher">
          <span class="none"></span>
        JSON-RPC - dispatcher</a>
            </li>
                
      <li class="active">
  
            <a href="#"><span class="none"></span>JSON-RPC - introspector</a>
          </li>
                
      <li>
  
                          <a href="../guide/netty.html" title="Netty I/O">
          <span class="none"></span>
        Netty I/O</a>
            </li>
                
      <li>
  
                          <a href="../guide/listener.html" title="Building listener">
          <span class="none"></span>
        Building listener</a>
            </li>
                
      <li>
  
                          <a href="../guide/daemon.html" title="Building daemon">
          <span class="none"></span>
        Building daemon</a>
            </li>
                
      <li>
  
                          <a href="../guide/client.html" title="Building client">
          <span class="none"></span>
        Building client</a>
            </li>
                
      <li>
  
                          <a href="../guide/json.html" title="JSON extras">
          <span class="none"></span>
        JSON extras</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                                                                                                                                                                                                      
      <li>
  
                          <a href="../project-info.html" title="Project Information">
          <span class="icon-chevron-right"></span>
        Project Information</a>
                  </li>
                                                                                                                                                                                                
      <li>
  
                          <a href="../project-reports.html" title="Project Reports">
          <span class="icon-chevron-right"></span>
        Project Reports</a>
                  </li>
            </ul>
              
                
          <hr />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                                                                                                                   <a href="http://maven.apache.org/" title="Maven" class="builtBy">
        <img class="builtBy"  alt="Apache Maven" src="http://maven.apache.org/images/logos/maven-feather.png"    />
      </a>
                                                                                                    <a href="http://chilldev.pl" title="Chillout Development" class="builtBy">
        <img class="builtBy"  alt="Chillout Development" src="http://static.chilldev.pl/images/chilldevpl.png"    />
      </a>
                                                                                                    <a href="http://wrzasq.pl" title="Wrzasq.pl" class="builtBy">
        <img class="builtBy"  alt="Wrzasq.pl" src="http://static.chilldev.pl/images/wrzasqpl.png"    />
      </a>
                      </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span10" >
                                  
            <!---
# This file is part of the ChillDev-Commons.
#
# @license http://mit-license.org/ The MIT license
# @copyright 2015 - 2016 © by Rafał Wrzeszcz - Wrzasq.pl.
--><h1>Service introspector</h1>
<p>With all the knowledge about how the dispatcher work, we can go step further and cover all of that with the introspection mechanism that will compose the dispatcher for us. For that we will have to use <tt>pl.chilldev.commons.jsonrpc.rpc.introspector.Introspector</tt> class. It takes the class, looks for all it&#x2019;s methods that are annotated with <tt>pl.chilldev.commons.jsonrpc.rpc.introspector.JsonRpcCall</tt> annotation and registers request handler for every such method. The logic here is as follows:</p>

<ul>
  
<li>method handler is registered in the dispatcher with the same name (possible to change via annotation);</li>
  
<li>for each method argument an RPC argument resolver is registered matching it&#x2019;s type;</li>
  
<li>arguments resolving is done based on method arguments names (possible to change via annotation);</li>
  
<li>method result is returned as a response (possible to be post-processed, unless <tt>void</tt>);</li>
  
<li><tt>JSONRPC2Error</tt> exceptions are exposed directly through respose, others are wrapped with <tt>JSONRPC2Error.INTERNAL_ERROR</tt>.</li>
</ul>
<p><b>Note:</b> As arguments resolving is by default done based on their names, your code needs to be compiled with <tt>-parameters</tt> argument to expose parameters names at runtime via reflection API. Otherwise you will have to explicitly define names for all arguments through annotations.</p>
<p>In order to use introspector, you first need to create a facade class (or interface) that will describe the API you want to expose in your dispatcher:</p>

<div class="source">
<div class="source"><pre class="prettyprint">import pl.chilldev.commons.jsonrpc.rpc.introspector.JsonRpcCall;

public interface ApiFacade
{
    @JsonRpcCall
    public String getPath(UUID id);

    // name property of the annotation allows you to override the JSON-RPC method name
    @JsonRpcCall(name = &quot;getPathByName&quot;)
    public String getPath(String name);

    // note lack of @JsonRpcCall annotation - this method won't be exposed
    public String getPath();
}
</pre></div></div>
<p>Once you have the class/interface, you may use introspector to populate the disptcher:</p>

<div class="source">
<div class="source"><pre class="prettyprint">import pl.chilldev.commons.jsonrpc.rpc.Dispatcher;
import pl.chilldev.commons.jsonrpc.rpc.introspector.Introspector;

public class DispatcherFactory
{
    public Dispatcher&lt;ApiFacade&gt; createDispatcher()
    {
        Dispatcher&lt;ApiFacade&gt; dispatcher = new Dispatcher&lt;&gt;();

        Introspector.createDefault().register(ApiFacade.class, dispatcher);

        // you can register owne method handlers

        return dispatcher;
    }
}
</pre></div></div>
<p><b>Note:</b> Introspector just populates the dispatcher, you can register own request handlers in the same dispatcher as well.</p>
<div class="section">
<h2><a name="Fine-tuning_parameters"></a>Fine-tuning parameters</h2>
<p>Apart from <tt>@JsonRpcCall</tt> annotation there is a second one, <tt>@JsonRpcParam</tt>, which allows for defining detailed metadata for each of the method parameters.</p>
<p><b>Note:</b> By default each method parameter is mendatory, however default status of <tt>optional</tt> flag of <tt>@JsonRpcParam</tt> annotation is <tt>true</tt>, so using this annotation on it&#x2019;s own automatically makes parameter optional.</p>
<p>The annotation has four attributes:</p>

<ul>
  
<li><tt>String name</tt> - can be used to override parameter name in JSON-RPC signature;</li>
  
<li><tt>boolean optional</tt> - optionality flag;</li>
  
<li><tt>String defaultValue</tt> - default value of the parameter (if optional) - due to <b>Java</b> limitations it must always be a <tt>String</tt>;</li>
  
<li><tt>boolean defaultNull</tt> - use this flag to set default parameter value to <tt>null</tt>, it has a precedence over <tt>defaultValue</tt> (it&#x2019;s introduced because of another <b>Java</b> stupid limitation, that annotation properties may not have <tt>null</tt> values).</li>
</ul>

<div class="source">
<div class="source"><pre class="prettyprint">import pl.chilldev.commons.jsonrpc.rpc.introspector.JsonRpcCall;
import pl.chilldev.commons.jsonrpc.rpc.introspector.JsonRpcParam;

public interface ApiFacade
{
    @JsonRpcCall
    public String calculateHash(
        // this one is mendatory, this is the default behavior
        String base,
        // this one is optional, default value is true
        @JsonRpcParam(defaultValue = &quot;true&quot;) boolean optionalBool,
        // this one is explicitely mendatory and fetched by different name
        @JsonRpcParam(name = &quot;name&quot;, optional = false) String id,
        // this one is optional and by default it's null
        @JsonRpcParam(defaultNull = true) String optionalString
    );
}
</pre></div></div></div>
<div class="section">
<h2><a name="Parameters_providers"></a>Parameters providers</h2>
<p>To handle method argument, a parameter provider needs to be registered for it&#x2019;s type. Parameter provider is responsible for retrieving parameter value from request based on it&#x2019;s name (and additional information, like default value).</p>
<p>Parameter provider takes four arguments:</p>

<ol style="list-style-type: decimal">
  
<li>request parameter name;</li>
  
<li>request parameters retriever;</li>
  
<li>optionality flag;</li>
  
<li>default value as a <tt>String</tt>.</li>
</ol>

<div class="source">
<div class="source"><pre class="prettyprint">introspector.registerParameterProvider(
    YourType.class
    (String name, ParamsRetriever params, boolean optional, String defaultValue) -&gt; {
        String value = optional ? params.getOptString(name, defaultValue) : params.getString(name);
        return YourType::fromString(value);
    }
);
</pre></div></div>
<p>Because of <b>Java</b> limitations regarding annotations, <tt>defaultValue</tt> will be a <tt>java.lang.String</tt> (may be <tt>null</tt>), you must decide on your own how to represent it in your type.</p>
<p><b>Note:</b> You have to register parameter provider before using introspector on your facade.</p>
<p><b>Note:</b> If any of arguments of your facade won&#x2019;t have registered provider, introspector will throw exception on attempt to register that facade.</p></div>
<div class="section">
<h2><a name="Response_mappers"></a>Response mappers</h2>
<p>It is also possible to register mappers for post-processing your response. It&#x2019;s mainly usable if you don&#x2019;t want to design your facades especially for <b>JSON-RPC</b> protocol and want to expose your standard methods that may return complex types. For instance standard introspector is capable of dumping <tt>org.springframework.data.domain.Page</tt> objects as a JSON-able structure.</p>
<p>Response type mapper is a simple mapping function that maps single argument (which is the invoked method result) into another value (that will be assigned as JSON-RPC response). It is also registered based on it&#x2019;s type:</p>

<div class="source">
<div class="source"><pre class="prettyprint">introspector.registerResultMapper(
    YourEntity.class,
    (YourEntity entity) -&gt; new YourTransferPojo(entity)
);
</pre></div></div>
<p><b>Note:</b> You have to register results mapper before using introspector on your facade.</p></div>
<div class="section">
<h2><a name="SPI"></a>SPI</h2>
<p>To make your custom types handling reusable and automatically discovered, you can use <tt>pl.chilldev.commons.jsonrpc.rpc.DispatcherModule</tt> and register it as your <b>SPI</b> implementation. When your module is discovered by SPI loader, it will automatically be applied to every introspector created with <tt>Introspector.createDefault()</tt>. Module interface has just one method that is entry point for introspector initialization:</p>

<div class="source">
<div class="source"><pre class="prettyprint">class YourModule implements DispatcherModule
{
    @Override
    public void initializeIntrospector(Introspector introspector)
    {
        introspector.registerParameterProvider(
            YourType.class
            (String name, ParamsRetriever params, boolean optional, String defaultValue) -&gt; {
                String value = optional ? params.getOptString(name, defaultValue) : params.getString(name);
                return YourType::fromString(value);
            }
        );

        introspector.registerResultMapper(
            YourEntity.class,
            (YourEntity entity) -&gt; new YourTransferPojo(entity)
        );
    }
}
</pre></div></div>
<p>And define it as your module implementation in <tt>META-INF/services/pl.chilldev.commons.jsonrpc.rpc.DispatcherModule</tt> file.</p>
<h1>Client introspector</h1>
<p>Similar mechanism exists for the client-side classes. All you have to do is to define an interface (can be also an abstract class) the maps to service methods (you even use same annotations):</p>

<div class="source">
<div class="source"><pre class="prettyprint">import java.util.List;
import java.util.UUID;

import pl.chilldev.commons.jsonrpc.rpc.introspector.JsonRpcCall;
import pl.chilldev.commons.jsonrpc.rpc.introspector.JsonRpcParam;

public interface MyClient
{
    @JsonRpcCall
    String getName(UUID id);

    @JsonRpcCall(name = &quot;getNameByEmail&quot;);
    String getName(String email);

    @JsonRpcCall
    List&lt;String&gt; getNames(@JsonRpcParam(name = &quot;ids&quot;) List&lt;UUID&gt; list);
}
</pre></div></div>
<p><tt>@JsonRpcCall</tt> annotation plays similar role that in the service introspector - it marks the method to be handled by the proxy interceptor and invoke the service method. It&#x2019;s additional <tt>name</tt> attribute allows you to change the actual invoked RPC method (by default it&#x2019;s same as method name).</p>
<p>Arguments are mapped by their names and it can also be changed by using <tt>name</tt> attribute of <tt>@JsonRpcParam</tt> annotation.</p>
<p><b>Note:</b> As all <b>JSON-RPC</b> mechanisms are handled internally, you don&#x2019;t need to worry about connector anymore - you simply don&#x2019;t need it.</p>
<p><b>Note:</b> Currently only public methods are handled, however it doesn&#x2019;t matter if they are defined directly in a class or inherited.</p>
<p>Not only interfaces are allowed, but also classes, so you can define additional methods that are not mapped to RPC calls. It&#x2019;s especially useful for handling custom, more complicated data types. For instance paged response results need requested page, so this is how we commonly solve the issue:</p>

<div class="source">
<div class="source"><pre class="prettyprint">import java.util.List;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import pl.chilldev.commons.jsonrpc.json.ConvertUtils;
import pl.chilldev.commons.jsonrpc.rpc.introspector.JsonRpcCall;

public abstract class MyClient
{
    @JsonRpcCall(name = &quot;getPage&quot;)
    public abstract List&lt;Object&gt; doGetPage(Pageable request);

    public Page&lt;MyEntity&gt; getPage(Pageable request)
    {
        return ConvertUtils.buildPage(
            this.doGetPage(request),
            request,
            MyEntity.class
        );
    }
}
</pre></div></div></div>
<div class="section">
<h2><a name="Instantiating_the_client"></a>Instantiating the client</h2>
<p>Ok, so we don&#x2019;t need to define the logic, all the errorneus and tedious work is done for us. But how to get the actual client instance? That&#x2019;s what you need <tt>pl.chilldev.commons.jsonrpc.client.introspector.Introspector</tt> for (note the different package name than for the service introspector).</p>

<div class="source">
<div class="source"><pre class="prettyprint">import pl.chilldev.commons.jsonrpc.client.introspector.Introspector;

// connector is an instance of pl.chilldev.commons.jsonrpc.client.Connector
Class&lt;MyClient&gt; clientType = Introspector.createDefault().createClient(MyClient.class, connector);
MyClient client = clientType.newInstance();

System.out.println(client.getName(&quot;test@localhost&quot;));
</pre></div></div></div>
<div class="section">
<h2><a name="Parameters_mappers"></a>Parameters mappers</h2>
<p>By default all parameters are passed as-they-are to the JSON dumper and they dumped into JSON structure (all non-standard JSON types are dumped by using their <tt>.toString()</tt> method). <tt>Introspector.createDefault()</tt> is also capable of handling <tt>org.springframework.data.domain.Pageable</tt> objects (they are dumped as three parameters for page number, page size and sorting criteria, the standard format supported by <tt>commons-jsonrpc</tt> stack. If you want to handle custom parameters in a different way, you can register own parameter mappers. A parameter mapper takes method parameter name, parameter value and current state of request params and is responsible for putting new parameter into the parameter map.</p>

<div class="source">
<div class="source"><pre class="prettyprint">introspector.registerParameterMapper(
    UUID.class,
    (String name, UUID value, Map&lt;String, Object&gt; params) -&gt; {
        params.put(name, value.toString());
    }
);
</pre></div></div>
<p><b>Note:</b> Such mapper is not needed as all objects are dumped with <tt>.toString()</tt> by default.</p></div>
<div class="section">
<h2><a name="Response_type_handlers"></a>Response type handlers</h2>
<p>It&#x2019;s also possible to handle custom response types. For example <tt>Introspector.createDefault()</tt> is capable of returning (apart of standard JSON types) also instances of <tt>java.util.UUID</tt> parsed with <tt>UUID.fromString()</tt> method. You can register your own function for handling custom types:</p>

<div class="source">
<div class="source"><pre class="prettyprint">introspector.registerResultHandler(
    MyEntity.class,
    (Object response) -&gt; ParamsRetriever.OBJECT_MAPPER.convertValue(response, MyEntity.class)
);
</pre></div></div></div>
<div class="section">
<h2><a name="SPI"></a>SPI</h2>
<p>The same way as for service introspector, client introspector can be also handled by SPI implementation. The flow is exactly the same - you have to define your module (even the entry point method is called the same), just instead of service introspector you have to initialize client introspector. The interface for client modules is <tt>pl.chilldev.commons.jsonrpc.client.ClientModule</tt>:</p>

<div class="source">
<div class="source"><pre class="prettyprint">class YourModule implements ClientModule
{
    @Override
    public void initializeIntrospector(Introspector introspector)
    {
        introspector.registerParameterMapper(
            UUID.class,
            (String name, UUID value, Map&lt;String, Object&gt; params) -&gt; {
                params.put(name, value.toString());
            }
        );

        introspector.registerResultHandler(
            MyEntity.class,
            (Object response) -&gt; ParamsRetriever.OBJECT_MAPPER.convertValue(response, MyEntity.class)
        );
    }
}
</pre></div></div>
<p>And define it as your module implementation in <tt>META-INF/services/pl.chilldev.commons.jsonrpc.rpc.ClientModule</tt> file.</p></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
                      <div class="row-fluid">
                                      <p >Copyright &copy;                    2015&#x2013;2016
                        <a href="http://wrzasq.pl/">Rafał Wrzeszcz - Wrzasq.pl</a>.
            All rights reserved.    
                  <li id="publishDate" class="pull-right">Last Published: 2016-08-27</li>
              <li id="projectVersion" class="pull-right">
                    Version: 0.1.2
        </li>
            </p>
                </div>

        
                </div>
    </footer>
        </body>
</html>
