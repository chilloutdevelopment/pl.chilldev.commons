/**
 * This file is part of the ChillDev-Commons.
 *
 * @license http://mit-license.org/ The MIT license
 * @copyright 2015 - 2016 © by Rafał Wrzeszcz - Wrzasq.pl.
 */

package test.pl.chilldev.commons.jsonrpc.client;

import java.net.InetSocketAddress;
import java.net.SocketAddress;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import com.thetransactioncompany.jsonrpc2.JSONRPC2Error;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Response;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.mockito.Matchers;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.internal.util.reflection.Whitebox;
import org.mockito.runners.MockitoJUnitRunner;

import pl.chilldev.commons.jsonrpc.client.Connector;
import pl.chilldev.commons.jsonrpc.client.RpcCallException;
import pl.chilldev.commons.jsonrpc.netty.RequestHandler;

@RunWith(MockitoJUnitRunner.class)
public class ConnectorTest
{
    private SocketAddress address = new InetSocketAddress("127.0.0.1", 1234);

    @Mock
    private Bootstrap bootstrap;

    @Mock
    private EventLoopGroup connectors;

    @Mock
    private RequestHandler handler;

    @Mock
    private Future<JSONRPC2Response> future;

    @Mock
    private ChannelFuture channelFuture;

    @Mock
    private Channel channel;

    @Before
    public void setUp()
    {
        Mockito.when(this.channelFuture.syncUninterruptibly()).thenReturn(this.channelFuture);
        Mockito.when(this.channelFuture.channel()).thenReturn(this.channel);
    }

    @Test
    public void setMaxPacketSize()
    {
        Connector connector = Connector.create(this.connectors, "127.0.0.1", 1234);

        int maxPacketSize = 123;
        connector.setMaxPacketSize(maxPacketSize);

        Assert.assertEquals(
            "Connector.setMaxPacketSize() should change maximum allowed packet size.",
            maxPacketSize,
            connector.getMaxPacketSize()
        );
    }

    @Test
    public void connect()
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);

        Whitebox.setInternalState(connector, "bootstrap", this.bootstrap);
        Mockito.when(this.bootstrap.connect(this.address)).thenReturn(this.channelFuture);

        Assert.assertSame(
            "Connector.connect() should return channel connection future generated by bootstrap.",
            this.channelFuture,
            connector.connect()
        );
    }

    @Test
    public void execute()
        throws
            InterruptedException,
            ExecutionException,
            JSONRPC2Error
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);

        Mockito.when(this.channel.isActive()).thenReturn(true);

        connector.reconnect(this.channelFuture);

        String result = "OK";
        JSONRPC2Response response = new JSONRPC2Response(result, "id");

        Mockito.when(this.handler.execute(Matchers.isA(JSONRPC2Request.class))).thenReturn(this.future);
        Mockito.when(this.future.get()).thenReturn(response);

        Assert.assertSame(
            "Connector.execute() should return executed method result.",
            result,
            connector.execute("test")
        );
    }

    @Test
    public void executeNewConnect()
        throws
            InterruptedException,
            ExecutionException,
            JSONRPC2Error
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);
        Connector spy = Mockito.spy(connector);

        String result = "OK";
        JSONRPC2Response response = new JSONRPC2Response(result, "id");

        Mockito.when(this.handler.execute(Matchers.isA(JSONRPC2Request.class))).thenReturn(this.future);
        Mockito.when(this.future.get()).thenReturn(response);
        Mockito.doReturn(this.channelFuture).when(spy).connect();

        Assert.assertSame(
            "Connector.execute() should return executed method result.",
            result,
            spy.execute("test")
        );
    }

    @Test
    public void executeReconnect()
        throws
            InterruptedException,
            ExecutionException,
            JSONRPC2Error
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);
        Connector spy = Mockito.spy(connector);

        Mockito.when(this.channel.isActive()).thenReturn(false);

        spy.reconnect(this.channelFuture);

        String result = "OK";
        JSONRPC2Response response = new JSONRPC2Response(result, "id");

        Mockito.when(this.handler.execute(Matchers.isA(JSONRPC2Request.class))).thenReturn(this.future);
        Mockito.when(this.future.get()).thenReturn(response);
        Mockito.doReturn(this.channelFuture).when(spy).connect();

        Assert.assertSame(
            "Connector.execute() should return executed method result.",
            result,
            spy.execute("test")
        );
    }

    @Test
    public void executeWithParams()
        throws
            InterruptedException,
            ExecutionException,
            JSONRPC2Error
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);

        Mockito.when(this.channel.isActive()).thenReturn(true);

        connector.reconnect(this.channelFuture);

        String result = "OK";
        JSONRPC2Response response = new JSONRPC2Response(result, "id");

        Map<String, Object> params = new HashMap<>();

        Mockito.when(this.handler.execute(Matchers.isA(JSONRPC2Request.class))).thenReturn(this.future);
        Mockito.when(this.future.get()).thenReturn(response);

        Assert.assertSame(
            "Connector.execute() should return executed method result.",
            result,
            connector.execute("test", params)
        );
    }

    @Test(expected = RpcCallException.class)
    public void executeThrowsJSONRPC2Error()
        throws
            InterruptedException,
            ExecutionException,
            JSONRPC2Error
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);

        Mockito.when(this.channel.isActive()).thenReturn(true);

        connector.reconnect(this.channelFuture);

        JSONRPC2Error error = new JSONRPC2Error(1, "error");
        JSONRPC2Response response = new JSONRPC2Response(error, "id");

        Mockito.when(this.handler.execute(Matchers.isA(JSONRPC2Request.class))).thenReturn(this.future);
        Mockito.when(this.future.get()).thenReturn(response);

        connector.execute("test");
    }

    @Test(expected = RpcCallException.class)
    public void executeThrowsInterruptedException()
        throws
            InterruptedException,
            ExecutionException,
            JSONRPC2Error
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);

        Mockito.when(this.channel.isActive()).thenReturn(true);

        connector.reconnect(this.channelFuture);

        Mockito.when(this.handler.execute(Matchers.isA(JSONRPC2Request.class))).thenReturn(this.future);
        Mockito.when(this.future.get()).thenThrow(new InterruptedException());

        connector.execute("test");
    }

    @Test(expected = RpcCallException.class)
    public void executeThrowsExecutionException()
        throws
            InterruptedException,
            ExecutionException,
            JSONRPC2Error
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);

        Mockito.when(this.channel.isActive()).thenReturn(true);

        connector.reconnect(this.channelFuture);

        Mockito.when(this.handler.execute(Matchers.isA(JSONRPC2Request.class))).thenReturn(this.future);
        Mockito.when(this.future.get()).thenThrow(new ExecutionException(new Exception()));

        connector.execute("test");
    }

    @Test
    public void reconnect()
    {
        Connector connector = new Connector(this.connectors, this.handler, this.address);

        connector.reconnect(this.channelFuture);
    }
}
