<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Introspector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ChillDev Commons JSON-RPC</a> &gt; <a href="index.source.html" class="el_package">pl.chilldev.commons.jsonrpc.rpc.introspector</a> &gt; <span class="el_source">Introspector.java</span></div><h1>Introspector.java</h1><pre class="source lang-java linenums">/**
 * This file is part of the ChillDev-Commons.
 *
 * @license http://mit-license.org/ The MIT license
 * @copyright 2015 - 2016 © by Rafał Wrzeszcz - Wrzasq.pl.
 */

package pl.chilldev.commons.jsonrpc.rpc.introspector;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.function.Function;

import com.thetransactioncompany.jsonrpc2.JSONRPC2Error;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Response;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import pl.chilldev.commons.jsonrpc.daemon.ContextInterface;
import pl.chilldev.commons.jsonrpc.json.ParamsRetriever;
import pl.chilldev.commons.jsonrpc.rpc.Dispatcher;
import pl.chilldev.commons.jsonrpc.rpc.DispatcherModule;
import pl.chilldev.commons.jsonrpc.rpc.handler.VersionHandler;

/**
 * Introspector for facade classes to automatically map method to JSON calls.
 */
<span class="fc" id="L37">public class Introspector</span>
{
    /**
     * Wrapper for parameter provider that reduces dependency to just request parameters retriever.
     *
     * @param &lt;Type&gt; Result type.
     */
    @FunctionalInterface
    interface ParameterProviderWrapper&lt;Type&gt;
    {
        /**
         * Fetches parameter from request.
         *
         * @param params Request parameters.
         * @return Resolved parameter.
         * @throws JSONRPC2Error When resolving parameter fails.
         */
        Type getParam(ParamsRetriever params)
            throws
                JSONRPC2Error;
    }

    /**
     * JSON-RPC call handler.
     *
     * @param &lt;ContextType&gt; Service request context type.
     */
    static class RequestHandler&lt;ContextType extends ContextInterface&gt;
        implements
            Dispatcher.RequestHandler&lt;ContextType&gt;
    {
        /**
         * Logger.
         */
<span class="fc" id="L71">        private Logger logger = LoggerFactory.getLogger(Introspector.RequestHandler.class);</span>

        /**
         * Target method.
         */
        private String method;

        /**
         * Parameters types.
         */
        private Class&lt;?&gt;[] types;

        /**
         * Parameters providers.
         */
        private Introspector.ParameterProviderWrapper&lt;?&gt;[] params;

        /**
         * Response mapper.
         */
        private Function&lt;Object, Object&gt; mapper;

        /**
         * Initializes handler for given method.
         *
         * @param method Method name.
         * @param types Parameters types.
         * @param params Parameters providers.
         * @param mapper Results mapper.
         */
        RequestHandler(
            String method,
            Class&lt;?&gt;[] types,
            Introspector.ParameterProviderWrapper&lt;?&gt;[] params,
            Function&lt;Object, Object&gt; mapper
        )
<span class="fc" id="L107">        {</span>
<span class="fc" id="L108">            this.method = method;</span>
<span class="fc" id="L109">            this.types = types;</span>
<span class="fc" id="L110">            this.params = params;</span>
<span class="fc" id="L111">            this.mapper = mapper;</span>
<span class="fc" id="L112">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public JSONRPC2Response process(JSONRPC2Request request, ContextType context)
            throws
                JSONRPC2Error
        {
<span class="fc" id="L122">            ParamsRetriever retriever = new ParamsRetriever(request.getNamedParams());</span>

            try {
<span class="fc" id="L125">                Method method = context.getClass().getMethod(</span>
                    this.method,
                    this.types
                );
<span class="fc" id="L129">                Object[] arguments = new Object[this.types.length];</span>

                // resolve call arguments
<span class="fc bfc" id="L132" title="All 2 branches covered.">                for (int i = 0; i &lt; this.params.length; ++i) {</span>
<span class="fc" id="L133">                    arguments[i] = this.params[i].getParam(retriever);</span>
                }

                // invoke handler method
                Object result;
                try {
<span class="fc" id="L139">                    result = method.invoke(context, arguments);</span>
<span class="fc" id="L140">                } catch (InvocationTargetException error) {</span>
<span class="fc" id="L141">                    this.logger.error(&quot;Error executing \&quot;{}\&quot;.&quot;, request.getMethod(), error);</span>

                    // unfold real exception
<span class="fc" id="L144">                    throw error.getCause();</span>
<span class="fc" id="L145">                }</span>

                // `void` method should just return response with ID
<span class="fc bfc" id="L148" title="All 2 branches covered.">                return method.getReturnType().equals(Void.TYPE)</span>
<span class="fc" id="L149">                    ? new JSONRPC2Response(request.getID())</span>
<span class="fc" id="L150">                    : new JSONRPC2Response(this.mapper.apply(result), request.getID());</span>
<span class="fc" id="L151">            } catch (JSONRPC2Error error) {</span>
                // just re-throw to the client
<span class="fc" id="L153">                throw error;</span>
                //CHECKSTYLE:OFF: IllegalCatchCheck
<span class="fc" id="L155">            } catch (Throwable error) {</span>
                //CHECKSTYLE:ON: IllegalCatchCheck
<span class="fc" id="L157">                throw JSONRPC2Error.INTERNAL_ERROR</span>
<span class="fc" id="L158">                    .appendMessage(&quot;: &quot; + error.getMessage());</span>
            }
        }
    }

    /**
     * Transparent response mapper.
     */
<span class="fc" id="L166">    private static final Function&lt;Object, Object&gt; IDENTITY_MAPPER = (Object value) -&gt; value;</span>

    /**
     * Server modules SPIs.
     */
<span class="fc" id="L171">    private static Set&lt;DispatcherModule&gt; modules = new HashSet&lt;&gt;();</span>

    /**
     * Logger.
     */
<span class="fc" id="L176">    private Logger logger = LoggerFactory.getLogger(Introspector.class);</span>

    /**
     * Parameters resolvers.
     */
<span class="fc" id="L181">    private Map&lt;Class&lt;?&gt;, ParameterProvider&lt;?&gt;&gt; resolvers = new HashMap&lt;&gt;();</span>

    /**
     * Results mappers.
     */
<span class="fc" id="L186">    private Map&lt;Class&lt;?&gt;, Function&lt;?, Object&gt;&gt; mappers = new HashMap&lt;&gt;();</span>

    static {
<span class="fc" id="L189">        ServiceLoader&lt;DispatcherModule&gt; loader = ServiceLoader.load(DispatcherModule.class);</span>
<span class="fc" id="L190">        loader.forEach(Introspector.modules::add);</span>
<span class="fc" id="L191">    }</span>

    /**
     * Registers parameter resolver for given class.
     *
     * @param type Parameter type.
     * @param resolver Parameter resolver.
     * @param &lt;Type&gt; Parameter type.
     */
    public &lt;Type&gt; void registerParameterProvider(
        Class&lt;Type&gt; type,
        ParameterProvider&lt;? extends Type&gt; resolver
    )
    {
<span class="fc" id="L205">        this.resolvers.put(type, resolver);</span>
<span class="fc" id="L206">    }</span>

    /**
     * Registers return type handler for given class.
     *
     * @param type Response type.
     * @param mapper Response mapper.
     * @param &lt;Type&gt; Response object type.
     */
    public &lt;Type&gt; void registerResultMapper(
        Class&lt;Type&gt; type,
        Function&lt;? super Type, Object&gt; mapper
    )
    {
<span class="fc" id="L220">        this.mappers.put(</span>
            type,
            mapper
        );
<span class="fc" id="L224">    }</span>

    /**
     * Registers request handlers for methods of given class in provided dispatcher.
     *
     * @param facade Request handling facade.
     * @param dispatcher Methods dispatcher.
     * @param &lt;ContextType&gt; Service request context type (will be used for execution context).
     * @throws IllegalArgumentException When a method of the facade can't be mapped to JSON-RPC call.
     */
    public &lt;ContextType extends ContextInterface&gt; void register(
        Class&lt;? super ContextType&gt; facade,
        Dispatcher&lt;? extends ContextType&gt; dispatcher
    )
    {
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (Method method : facade.getMethods()) {</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">            if (method.isAnnotationPresent(JsonRpcCall.class)) {</span>
<span class="fc" id="L241">                this.logger.debug(&quot;Found {}.{} method as JSON-RPC handler.&quot;, facade.getName(), method.getName());</span>

<span class="fc" id="L243">                this.register(method, dispatcher);</span>
            }
        }
<span class="fc" id="L246">    }</span>

    /**
     * Registers single method.
     *
     * @param method Method to handle.
     * @param dispatcher Methods dispatcher.
     * @param &lt;ContextType&gt; Service request context type (will be used for execution context).
     * @throws IllegalArgumentException When a method of the facade can't be mapped to JSON-RPC call.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;ContextType extends ContextInterface&gt; void register(
        Method method,
        Dispatcher&lt;? extends ContextType&gt; dispatcher
    )
    {
<span class="fc" id="L262">        JsonRpcCall call = method.getAnnotation(JsonRpcCall.class);</span>

<span class="fc" id="L264">        Parameter[] parameters = method.getParameters();</span>
<span class="fc" id="L265">        Introspector.ParameterProviderWrapper&lt;?&gt;[] providers</span>
            = new Introspector.ParameterProviderWrapper[parameters.length];

        try {
            // build parameters resolvers
<span class="fc bfc" id="L270" title="All 2 branches covered.">            for (int i = 0; i &lt; parameters.length; ++i) {</span>
                // register synthetic RPC handler
<span class="fc" id="L272">                providers[i] = this.createParameterProvider(parameters[i]);</span>
            }
<span class="fc" id="L274">        } catch (IllegalArgumentException error) {</span>
<span class="fc" id="L275">            throw new IllegalArgumentException(</span>
<span class="fc" id="L276">                String.format(</span>
                    &quot;%s.%s() cann't be mapped to JSON-RPC handler.&quot;,
<span class="fc" id="L278">                    method.getDeclaringClass().getName(),</span>
<span class="fc" id="L279">                    method.getName()</span>
                ),
                error
            );
<span class="fc" id="L283">        }</span>

<span class="fc" id="L285">        Class&lt;?&gt; response = method.getReturnType();</span>
<span class="fc" id="L286">        dispatcher.register(</span>
            // use overridden name if set
<span class="fc bfc" id="L288" title="All 2 branches covered.">            call.name().isEmpty() ? method.getName() : call.name(),</span>
            new Introspector.RequestHandler&lt;ContextType&gt;(
<span class="fc" id="L290">                method.getName(),</span>
<span class="fc" id="L291">                method.getParameterTypes(),</span>
                providers,
                // fall back to transparent mapper if no type-specific mapper is registered
<span class="fc bfc" id="L294" title="All 2 branches covered.">                this.mappers.containsKey(response)</span>
<span class="fc" id="L295">                    ? (Function&lt;Object, Object&gt;) this.mappers.get(response)</span>
<span class="fc" id="L296">                    : Introspector.IDENTITY_MAPPER</span>
            )
        );
<span class="fc" id="L299">    }</span>

    /**
     * Creates provider for given parameter.
     *
     * @param parameter Method parameter.
     * @param &lt;Type&gt; Parameter type.
     * @return Parameter provider.
     * @throws IllegalArgumentException When a parameter cann't be resolved from JSON-RPC request.
     */
    private &lt;Type&gt; Introspector.ParameterProviderWrapper&lt;Type&gt; createParameterProvider(Parameter parameter)
    {
        // try to fetch provider by parameter type
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L313">        ParameterProvider&lt;Type&gt; provider = (ParameterProvider&lt;Type&gt;) this.resolvers.get(parameter.getType());</span>

        // not supported parameter type
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (provider == null) {</span>
<span class="fc" id="L317">            throw new IllegalArgumentException(</span>
<span class="fc" id="L318">                String.format(</span>
                    &quot;\&quot;%s\&quot; parameter type (%s) is not supported&quot;,
<span class="fc" id="L320">                    parameter.getName(),</span>
<span class="fc" id="L321">                    parameter.getType().getName()</span>
                )
            );
        }

<span class="fc" id="L326">        String name = parameter.getName();</span>
<span class="fc" id="L327">        String defaultValue = null;</span>
<span class="fc" id="L328">        boolean optional = false;</span>

        // override defaults if annotation is defined
<span class="fc" id="L331">        JsonRpcParam metadata = parameter.getAnnotation(JsonRpcParam.class);</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (metadata != null) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            name = metadata.name().isEmpty() ? name : metadata.name();</span>
<span class="fc" id="L334">            optional = metadata.optional();</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">            defaultValue = metadata.defaultNull() ? null : metadata.defaultValue();</span>
        }

<span class="fc" id="L338">        return this.createParameterProviderWrapper(provider, name, optional, defaultValue);</span>
    }

    /**
     * Creates parameter provider wrapper for given parameter scope.
     *
     * @param provider Value provider.
     * @param name Parameter name.
     * @param optional Optional flag.
     * @param defaultValue Default value.
     * @param &lt;Type&gt; Parameter type.
     * @return Wrapped parameter provider.
     */
    private &lt;Type&gt; Introspector.ParameterProviderWrapper&lt;Type&gt; createParameterProviderWrapper(
        ParameterProvider&lt;? extends Type&gt; provider,
        String name,
        boolean optional,
        String defaultValue
    )
    {
<span class="fc" id="L358">        return (ParamsRetriever params) -&gt; provider.getParam(name, params, optional, defaultValue);</span>
    }

    /**
     * Creates dispatcher for given facade type.
     *
     * &lt;p&gt;
     * Created dispatcher contains additional &lt;tt&gt;version&lt;/tt&gt; method handler.
     * &lt;/p&gt;
     *
     * @param type Class to be used as a facade.
     * @param &lt;ContextType&gt; Service request context type (will be used for execution context).
     * @return Dispatcher.
     */
    public &lt;ContextType extends ContextInterface&gt; Dispatcher&lt;ContextType&gt; createDispatcher(Class&lt;ContextType&gt; type)
    {
<span class="fc" id="L374">        Dispatcher&lt;ContextType&gt; dispatcher = new Dispatcher&lt;&gt;();</span>
<span class="fc" id="L375">        dispatcher.register(&quot;version&quot;, new VersionHandler());</span>

<span class="fc" id="L377">        this.register(type, dispatcher);</span>

<span class="fc" id="L379">        return dispatcher;</span>
    }

    /**
     * Creates introspector initializes with SPI services.
     *
     * @return Introspector.
     */
    public static Introspector createDefault()
    {
<span class="fc" id="L389">        Introspector introspector = new Introspector();</span>

<span class="fc" id="L391">        Introspector.modules.forEach((DispatcherModule module) -&gt; module.initializeIntrospector(introspector));</span>

<span class="fc" id="L393">        return introspector;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>