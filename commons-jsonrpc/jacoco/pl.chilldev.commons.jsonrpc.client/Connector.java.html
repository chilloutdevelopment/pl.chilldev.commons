<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Connector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ChillDev Commons JSON-RPC</a> &gt; <a href="index.source.html" class="el_package">pl.chilldev.commons.jsonrpc.client</a> &gt; <span class="el_source">Connector.java</span></div><h1>Connector.java</h1><pre class="source lang-java linenums">// Generated by delombok at Sat Aug 27 09:26:47 UTC 2016
/**
 * This file is part of the ChillDev-Commons.
 *
 * @license http://mit-license.org/ The MIT license
 * @copyright 2015 - 2016 © by Rafał Wrzeszcz - Wrzasq.pl.
 */
package pl.chilldev.commons.jsonrpc.client;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Error;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Request;
import com.thetransactioncompany.jsonrpc2.JSONRPC2Response;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pl.chilldev.commons.jsonrpc.netty.RequestHandler;
import pl.chilldev.commons.jsonrpc.netty.StringChannelInitializer;

/**
 * Single TCP client.
 */
public class Connector implements StringChannelInitializer.Configuration {
    /**
     * Default packet size limit.
     */
    public static final int DEFAULT_PACKET_LIMIT = 33554432;
    /**
     * Request ID seed.
     */
    private static long id;
    /**
     * Logger.
     */
<span class="fc" id="L43">    private Logger logger = LoggerFactory.getLogger(Connector.class);</span>
    /**
     * Destination address.
     */
    private SocketAddress address;
    /**
     * Maximum size of JSON-RPC packet.
     */
<span class="fc" id="L51">    private int maxPacketSize = Connector.DEFAULT_PACKET_LIMIT;</span>
    /**
     * Client connector bootstrap.
     */
<span class="fc" id="L55">    private Bootstrap bootstrap = new Bootstrap();</span>
    /**
     * JSON-RCP handler.
     */
    private RequestHandler handler;
    /**
     * Current connection session.
     */
    private Channel session;

    /**
     * Initializes connector with given configuration.
     *
     * @param connectors Connectors thread pool.
     * @param handler JSON-RPC request handler.
     * @param address Server address.
     */
<span class="fc" id="L72">    public Connector(EventLoopGroup connectors, RequestHandler handler, SocketAddress address) {</span>
<span class="fc" id="L73">        this.handler = handler;</span>
<span class="fc" id="L74">        this.address = address;</span>
<span class="fc" id="L75">        this.bootstrap.group(connectors).channel(NioSocketChannel.class).handler(new StringChannelInitializer&lt;Channel&gt;(this.handler, this));</span>
<span class="fc" id="L76">    }</span>

    /**
     * Executes remote call without parameters.
     *
     * @param method Method name.
     * @return Response.
     * @throws RpcCallException When execution fails.
     */
    public Object execute(String method) {
<span class="fc" id="L86">        long id = Connector.generateRequestId();</span>
<span class="fc" id="L87">        return this.execute(new JSONRPC2Request(method, id));</span>
    }

    /**
     * Executes remote call with parameters.
     *
     * @param method Method name.
     * @param params RPC params.
     * @return Response.
     * @throws RpcCallException When execution fails.
     */
    public Object execute(String method, Map&lt;String, Object&gt; params) {
<span class="fc" id="L99">        long id = Connector.generateRequestId();</span>
<span class="fc" id="L100">        return this.execute(new JSONRPC2Request(method, params, id));</span>
    }

    /**
     * Executes queued RPC call.
     *
     * @param request JSON-RPC request.
     * @return Method result.
     * @throws RpcCallException When execution fails.
     */
    private Object execute(JSONRPC2Request request) {
        // (re-)connect if needed
<span class="fc bfc" id="L112" title="All 4 branches covered.">        if (this.session == null || !this.session.isActive()) {</span>
<span class="fc" id="L113">            this.reconnect(this.connect());</span>
        }
        try {
            // first register request to listen for the response
<span class="fc" id="L117">            Future&lt;JSONRPC2Response&gt; future = this.handler.execute(request);</span>
            // send request to server
<span class="fc" id="L119">            this.session.writeAndFlush(request);</span>
<span class="fc" id="L120">            JSONRPC2Response response = future.get();</span>
            // server-side error
<span class="fc bfc" id="L122" title="All 2 branches covered.">            if (!response.indicatesSuccess()) {</span>
<span class="fc" id="L123">                JSONRPC2Error error = response.getError();</span>
<span class="fc" id="L124">                this.logger.error(&quot;Response ID: {}, error #{}: {}.&quot;, response.getID(), error.getCode(), error.getMessage());</span>
<span class="fc" id="L125">                throw error;</span>
            }
<span class="fc" id="L127">            return response.getResult();</span>
<span class="fc" id="L128">        } catch (InterruptedException error) {</span>
<span class="fc" id="L129">            this.logger.error(&quot;Error while waiting for asynchronous response: {}.&quot;, error.getMessage());</span>
<span class="fc" id="L130">            throw new RpcCallException(error);</span>
<span class="fc" id="L131">        } catch (ExecutionException error) {</span>
<span class="fc" id="L132">            this.logger.error(&quot;Error while executing asynchronous response handler: {}.&quot;, error.getMessage());</span>
<span class="fc" id="L133">            throw new RpcCallException(error.getCause());</span>
<span class="fc" id="L134">        } catch (JSONRPC2Error error) {</span>
<span class="fc" id="L135">            this.logger.error(&quot;Server returned error response: {}.&quot;, error.getMessage());</span>
<span class="fc" id="L136">            throw new RpcCallException(error);</span>
        }
    }

    /**
     * Connects to server.
     *
     * @return Connection establishing future.
     */
    public ChannelFuture connect() {
<span class="fc" id="L146">        return this.bootstrap.connect(this.address);</span>
    }

    /**
     * Enforces connection to server.
     *
     * @param future Connection establishing future.
     */
    public void reconnect(ChannelFuture future) {
<span class="fc" id="L155">        this.session = future.syncUninterruptibly().channel();</span>
<span class="fc" id="L156">    }</span>

    /**
     * Creates connector instance with default resources.
     *
     * @param connectors Connectors thread pool.
     * @param address Server address.
     * @return Client connector.
     */
    public static Connector create(EventLoopGroup connectors, SocketAddress address) {
<span class="fc" id="L166">        return new Connector(connectors, new RequestHandler(), address);</span>
    }

    /**
     * Creates connector instance with default resources.
     *
     * @param connectors Connectors thread pool.
     * @param host Listen host.
     * @param port Listen port.
     * @return Client connector.
     */
    public static Connector create(EventLoopGroup connectors, String host, int port) {
<span class="fc" id="L178">        return Connector.create(connectors, new InetSocketAddress(host, port));</span>
    }

    /**
     * Generates new request ID.
     *
     * @return Request ID.
     */
    private static long generateRequestId() {
<span class="fc" id="L187">        return Connector.id++;</span>
    }

    /**
     * Maximum size of JSON-RPC packet.
     */
    @SuppressWarnings(&quot;all&quot;)
    @javax.annotation.Generated(&quot;lombok&quot;)
    public int getMaxPacketSize() {
<span class="fc" id="L196">        return this.maxPacketSize;</span>
    }

    /**
     * Maximum size of JSON-RPC packet.
     */
    @SuppressWarnings(&quot;all&quot;)
    @javax.annotation.Generated(&quot;lombok&quot;)
    public void setMaxPacketSize(final int maxPacketSize) {
<span class="fc" id="L205">        this.maxPacketSize = maxPacketSize;</span>
<span class="fc" id="L206">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>